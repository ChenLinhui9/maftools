#' Extract mutational signatures from trinucleotide context.
#'
#' @description Decompose a matrix of 96 substitution classes into \code{n} signatures.
#'
#' @details This function decomposes a non-negative matrix into n signatures.
#' Extracted signatures are compared against 30 experimentally validated signatures by calculating cosine similarity. See http://cancer.sanger.ac.uk/cosmic/signatures for details.
#'
#' @param mat Input matrix of diemnsion nx96 generated by \code{\link{trinucleotideMatrix}}
#' @param n decompose matrix into n signatures. Default NULL. Tries to predict best value for \code{n} by running NMF on a range of values and chooses based on cophenetic correlation coefficient.
#' @param nTry tries upto this number of signatures before choosing best \code{n}. Default 6.
#' @param plotBestFitRes plots consensus heatmap for range of values tried. Default FALSE
#' @param parallel calls to .opt argument of \code{\link{nmf}}. e.g, 'P4' for using 4 cores. See note on \code{\link{nmf}} for MAC users.
#' @param pConstant A small positive value to add to the matrix. Use it ONLY if the functions throws an \code{non-conformable arrays} error
#' @return a list with decomposed scaled signatures, signature contributions in each sample and a cosine similarity table against validated signatures.
#' @examples
#' \dontrun{
#' laml.tnm <- trinucleotideMatrix(maf = laml, ref_genome = 'hg19.fa', prefix = 'chr',
#' add = TRUE, useSyn = TRUE)
#' laml.sign <- extractSignatures(mat = laml.tnm, plotBestFitRes = FALSE)
#' }
#' @seealso \code{\link{trinucleotideMatrix}} \code{\link{plotSignatures}} \code{\link{compareSignatures}}
#' @export


extractSignatures = function(mat, n = NULL, nTry = 6, plotBestFitRes = FALSE, parallel = NULL, pConstant = NULL){

    #suppressPackageStartupMessages(require(NMF, quietly = TRUE))
    #transpose matrix
  start_time = proc.time()
    mat = t(mat$nmf_matrix)

    #Validation
    zeroMutClass = names(which(rowSums(mat) == 0))

    if(length(zeroMutClass)){
      cat('-Found zero mutations for conversions:\n')
      for(temp in zeroMutClass){
        cat(paste0("  ", temp, "\n"))
      }
      #Add small value to avoid zero counts (maybe not appropriate). This happens when sample size is low or in cancers with low mutation rate.
      #mat[which(rowSums(mat) == 0),] = 0.1
    }

    #To avoid error due to non-conformable arrays
    if(!is.null(pConstant)){
      if(pConstant < 0 | pConstant == 0){
        stop("pConstant must be > 0")
      }
      mat = mat+pConstant
    }

    #Notes:
    #Available methods for nmf decompositions are 'brunet', 'lee', 'ls-nmf', 'nsNMF', 'offset'.
    #But based 21 breast cancer signatures data, defualt brunet seems to be working close to the results.
    #Sticking with default for now.

    nmf.sum = NULL
    if(is.null(n)){
      cat('-Estimating optimal factorization rank\n')
      if(!is.null(parallel)){
        nmfTry = NMF::nmfEstimateRank(mat, seq(2,nTry), method='brunet', nrun=10, seed=123456, .opt = parallel) #try nmf for a range of values
      }else{
        nmfTry = NMF::nmfEstimateRank(mat, seq(2,nTry), method='brunet', nrun=10, seed=123456) #try nmf for a range of values
      }

      if(plotBestFitRes){
        pdf('nmf_consensus.pdf', bg = 'white', pointsize = 9, width = 12, height = 12, paper = "special")
        NMF::consensusmap(nmfTry)
        dev.off()
        cat('-created nmf_consensus.pdf\n')
        #print(NMF::plot(nmfTry, 'cophenetic'))
      }

      nmf.sum = summary(nmfTry) # Get summary of estimates
      data.table::setDT(nmf.sum)

      nmf.sum$diff = c(0, diff(nmf.sum$cophenetic))
      bestFit = nmf.sum[diff < 0, rank][1] #First point where cophenetic correlation coefficient starts decreasing

      #Thanks Valentin for the below method for optimal rank estimation
      #Take second derivitive of fitted line for optimal rank
      #sig_fit = smooth.spline(y = c(1, 1-diff(nmf.sum$cophenetic)), x = nmf.sum$rank)
      #sig_deriv = predict(object = sig_fit, deriv = 2)
      #sig_min = which(sig_deriv$y == min(sig_deriv$y))
      #bestFit = nmf.sum$rank[sig_min-1]

      par(mar = c(3, 3, 2, 1))
      plot(nmf.sum$rank, nmf.sum$cophenetic, axes = FALSE, pch = 16, col = "#D8B365", cex = 1, xlab = NA, ylab = NA, ylim = range(pretty(nmf.sum$cophenetic)))
      axis(side = 1, at = nmf.sum$rank, labels = nmf.sum$rank, lwd = 1, font = 1, cex.axis = 1)
      lines(x = nmf.sum$rank, y = round(nmf.sum$cophenetic, digits = 4), lwd = 1)
      points(nmf.sum$rank, nmf.sum$cophenetic, pch = 16, col = "#D8B365", cex = 1.6)
      axis(side = 2, at = pretty(nmf.sum$cophenetic), lwd = 1, font = 1, las = 2, cex = 1, cex.axis = 1)
      segments(x0 = bestFit, y0 = 0, x1 = bestFit, y1 = nmf.sum[rank == bestFit, cophenetic], lwd= 1, lty = 1, col = "maroon")
      title(main = "cophenetic metric", adj = 0, font.main = 4)

      #bestFit = nmf.sum[which(nmf.sum$cophenetic == max(nmf.sum$)),'rank'] #Get the best rank based on highest cophenetic correlation coefficient
      cat(paste('--Using ',bestFit, ' as the best-fit factorization rank\n', sep=''))
      warning("Consult elbow plot and re-consider the estimated number of signatures if necessary")
      n = as.numeric(bestFit)
      cat('--------------------------------------\n')
    }

    cat(paste0('-Running NMF for factorization rank: ', n, '\n'))
    if(!is.null(parallel)){
      conv.mat.nmf = NMF::nmf(x = mat, rank = n, .opt = parallel, seed = 123456)
    }else{
      conv.mat.nmf = NMF::nmf(x = mat, rank = n, seed = 123456)
    }

    #Signatures
    w = NMF::basis(conv.mat.nmf)
    w = apply(w, 2, function(x) x/sum(x)) #Scale the signatures (basis)
    colnames(w) = paste('Signature', 1:ncol(w),sep='_')

    #Contribution
    h = NMF::coef(conv.mat.nmf)
    colnames(h) = colnames(mat) #correct colnames (seems to be mssing with low mutation load)
    #For single signature, contribution will be 100% per sample
    if(n == 1){
      h = h/h
      rownames(h) = paste('Signature', '1', sep = '_')
    }else{
      h = apply(h, 2, function(x) x/sum(x)) #Scale contributions (coefs)
      rownames(h) = paste('Signature', 1:nrow(h),sep='_')
    }

    sigs = data.table::fread(input = system.file('extdata', 'signatures.txt', package = 'maftools'), stringsAsFactors = FALSE, data.table = FALSE)
    colnames(sigs) = gsub(pattern = ' ', replacement = '_', x = colnames(sigs))
    rownames(sigs) = sigs$Somatic_Mutation_Type
    sigs = sigs[,-c(1:3)]
    sigs = sigs[rownames(w),]

    aetiology = structure(list(aetiology = c("spontaneous deamination of 5-methylcytosine",
                                             "APOBEC Cytidine Deaminase (C>T)", "defects in DNA-DSB repair by HR",
                                             "exposure to tobacco (smoking) mutagens", "Unknown", "defective DNA mismatch repair",
                                             "UV exposure", "Unknown", "defects in polymerase-eta", "defects in polymerase POLE",
                                             "exposure to alkylating agents", "Unknown", "APOBEC Cytidine Deaminase (C>G)",
                                             "Unknown", "defective DNA mismatch repair", "Unknown", "Unknown",
                                             "Unknown", "Unknown", "defective DNA mismatch repair", "unknown",
                                             "exposure to aristolochic acid", "Unknown", "exposures to aflatoxin",
                                             "Unknown", "defective DNA mismatch repair", "Unknown", "Unknown",
                                             "exposure to tobacco (chewing) mutagens", "Unknown")), .Names = "aetiology", row.names = c("Signature_1",
                                                                                                                                        "Signature_2", "Signature_3", "Signature_4", "Signature_5", "Signature_6",
                                                                                                                                        "Signature_7", "Signature_8", "Signature_9", "Signature_10",
                                                                                                                                        "Signature_11", "Signature_12", "Signature_13", "Signature_14",
                                                                                                                                        "Signature_15", "Signature_16", "Signature_17", "Signature_18",
                                                                                                                                        "Signature_19", "Signature_20", "Signature_21", "Signature_22",
                                                                                                                                        "Signature_23", "Signature_24", "Signature_25", "Signature_26",
                                                                                                                                        "Signature_27", "Signature_28", "Signature_29", "Signature_30"
                                             ), class = "data.frame")

    cat('-Comparing against COSMIC signatures\n')
    cat('------------------------------------\n')
    #corMat = c()
    coSineMat = c()
    for(i in 1:ncol(w)){
      sig = w[,i]
      coSineMat = rbind(coSineMat, apply(sigs, 2, function(x){
        round(crossprod(sig, x)/sqrt(crossprod(x) * crossprod(sig)), digits = 3) #Estimate cosine similarity against all 30 signatures
      }))
      #corMat = rbind(corMat, apply(sigs, 2, function(x) cor.test(x, sig)$estimate[[1]])) #Calulate correlation coeff.
    }
    #rownames(corMat) = colnames(w)
    rownames(coSineMat) = colnames(w)

    for(i in 1:nrow(coSineMat)){
      ae = aetiology[names(which(coSineMat[i,] == max(coSineMat[i,]))),]
      ae = paste0("Aetiology: ", ae, " [cosine-similarity: ", max(coSineMat[i,]), "]")
      cat('--Found ',rownames(coSineMat)[i], ' most similar COSMIC ', names(which(coSineMat[i,] == max(coSineMat[i,]))), '.\n',sep='')
      cat(paste0('   ', ae, '\n'))
    }
    cat('------------------------------------\n')

    cat("-Finished in",data.table::timetaken(start_time),"\n")
    return(list(signatures = w, contributions = h, coSineSimMat = coSineMat, nmfObj = conv.mat.nmf, nmfSummary = nmf.sum))
}
